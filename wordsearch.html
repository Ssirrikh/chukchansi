<!DOCTYPE html>
<html lang='en' xml:lang='en'>
<head>
	<meta charset = 'utf-8'>
    <title>Chukchansi Wordsearch</title>
    <meta name='robots' content='index, follow'>
    <meta name='description' content='A fun and educational Chukchansi wordsearch puzzle for language learners to practice word recognition.'>
	<meta name='viewport' content='width=device-width, initial-scale=1'>
    <style>
        :root {
			--background-nav: #461220; /* navbar */
            --text-nav: #ffd994; /* previously #ffdab3 */
            --border-nav: #64182c; /* #64182c, #771932 */

            --background-nav-selected: #6b4226;
            --background-nav-unselected: #eac8a2;

			--background-light: #f2e3d3; /* main content bg */
			--background-inset: #dbb78f; /* inset panels; vibrant bg */
			--background-medium: #bfa07e; /* side panels; muted bg */
			--background-dark: #ad8e6c; /* fractionally darker interactibles bg */
			--text-dark: #4f3a09; /* main content text */
			--text-medium: #806d46; /* interactible text */
			--text-light: #fdf7ea;

			--border-dark: #4f3a09; /* content separation */
			--border-medium: #75544b; /* inset panel border */
			--border-light: #bfa07e; /* interactible textbox border */

            --popout-shadow: 0 0 10px #00000038;

			--layer-front: 2; /* elems that hover over content (hanging tabs, search history) */
			--layer-nav: 3; /* nav elements are always topmost */
			--layer-overlay: 5; /* modal overlays */

            /* dynamic units calculated for mobile-first; see media queries for desktop */
            --fluid-font-size: max(2.5vh, calc(1rem + 1.0vw));
            /* --fluid-font-size: calc(1rem + 1.0vw); */
            /* --fluid-font-size: 2.5vh; */
            --nav-pad: 0.25em;
            --content-pad: 0.8rem;
            --title-font-size: calc(1.17 * var(--fluid-font-size)); /* unsure why 1.17, but it seems to be pixel-perfect at all sizes */
            --nav-height: calc(1.75 * var(--fluid-font-size)); /* ref height for content anchors */

			--wordsearch-grid-size: 11;
            --wordsearch-pad: 0.25em;
            --wordsearch-width: max(min(60vh, calc(100vw - 2 * var(--content-pad))));
            /* --wordsearch-width: calc(100vw - 2 * var(--content-pad)); */
            --wordsearch-tile-width: calc(calc(var(--wordsearch-width) - 2 * var(--wordsearch-pad)) / var(--wordsearch-grid-size));
            --wordsearch-tile-font-size: calc(0.7 * var(--wordsearch-tile-width));
		}

		* {
			margin: 0px;
			padding: 0px;
			box-sizing: border-box;
			font-family: 'Times New Roman';
		}
		body {
			background-color: var(--background-nav);
            font-size: var(--fluid-font-size);
		}
        button {
            color: var(--text-dark);
            background-color: transparent;
            border: none;
            outline: none;
        }

        /* flexbox */
		.flex-sep {
			width: 0;
			flex-grow: 1;
		}
		.flex-row {
			display: flex;
			flex-direction: row;
			align-items: start;
		}
		.flex-col {
			display: flex;
			flex-direction: column;
		}
        .flex-adapt {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .flex-adapt-reverse {
            flex-direction: row;
            align-items: normal;
            justify-content: center;
        }

        /**** NAV BAR ****/

		#nav-bar {
			color: var(--text-nav);
			background-color: var(--background-nav);
            border-bottom: 1px solid var(--border-nav);

			position: sticky;
			padding: var(--nav-pad);
			top: 0px;
			width: 100%;
            font-size: var(--title-font-size);
            text-align: center;

			z-index: var(--layer-nav); /* nav elems and hanging tabs are on top of other content, but not fullscreen modals */
		}
        #nav-title {
            /* unstyle <h1> */
            font-size: var(--title-font-size);
            line-height: var(--title-font-size);
            font-weight: normal;
        }
        #nav-menu {
            /* https://www.sliderrevolution.com/resources/css-dropdown-menu/ */
            cursor: pointer;

            display: inline-block;
            position: absolute;
            top: 0px;
            left: 0px;
            width: var(--nav-height);
            height: var(--nav-height);
        }
        #nav-menu ul {
            cursor: default;
            color: var(--text-dark);
            background-color: var(--background-nav-unselected);
            /* border-top: 1px solid var(--text-light); */
            border-bottom: 1px solid var(--border-light);

            visibility: hidden;
            position: absolute;
            top: var(--nav-height);
            left: 0px;
            width: 100vw;
            padding: 0.25em;

            text-align: left;
            list-style: none;
            flex-wrap: wrap;
        }
        #nav-menu div + div {
            border-left: 1px solid var(--text-dark);
        }
        #nav-menu ul li {
            cursor: pointer;
            color: var(--text-dark);
            /* padding: 0.15em 0.75em; */
            font-size: 0.8em;
        }
        #nav-menu ul li:hover {
            color: var(--text-nav);
            background-color: var(--background-nav-selected);
        }
        #nav-menu:focus-within > ul, #nav-menu:hover ul {
            visibility: visible;
        }
        #nav-menu ul li a {
            /* border: 1px solid blue; */
            display: inline-block;
            width: 100%;
            padding: 0.15em 0.75em;
            color: inherit;
            text-decoration: inherit;
        }
        .nav-greyed-out {
            cursor: default;
            color: var(--text-dark);
            padding: 0.15em 0.75em;
            font-size: 0.8em;
            opacity: 50%;
        }

        /**** SITE LAYOUT ****/

        #content {
            background-color: var(--background-inset);
            min-height: calc(100vh - var(--nav-height));

            padding: var(--content-pad);

            gap: var(--content-pad);
            flex-direction: column-reverse;
            justify-content: start;
        }
        #wordlist-wrapper {
            /* border-radius: 0.5em; */
            /* box-shadow: var(--popout-shadow); */

            width: var(--wordsearch-width);
            font-size: 0.8em;

            align-items: center;
            gap: var(--content-pad);
        }
        #wordsearch-wrapper {
            user-select: none;
            color: var(--text-dark);
            background-color: var(--background-light);
            border-radius: 0.5em;
            box-shadow: var(--popout-shadow);

            display: inline-block;
            position: relative;
            width: var(--wordsearch-width);
            height: var(--wordsearch-width);
            padding: var(--wordsearch-pad);
            font-size: var(--wordsearch-tile-font-size);
            line-height: var(--wordsearch-tile-font-size);
        }

        .word-group {
            white-space: nowrap;
        }

        /**** NEW GAME HEADER ****/

        #new-game-button {
            cursor: pointer;
            color: var(--text-nav);
            background-color: var(--background-nav);
            border-radius: 0.5em;
            filter: drop-shadow(var(--popout-shadow));

            width: 100%;
            padding: 0.5em;
            text-align: center;
            text-decoration: none;
        }
        #new-game-button:hover {
            text-decoration: underline;
        }

        #new-game-wrapper {
            background-color: var(--background-light);
            display: none; /* invisible until toggled on */
            position: absolute;
            width: 100%;
            height: 100%;
        }

        /**** WORD LIST ****/

        #wordlist {
            background-color: var(--background-inset);
            border-radius: 0.5em;
            filter: drop-shadow(var(--popout-shadow));
            overflow: scroll;
            flex-grow: 1;
        }
        .wordlist-header {
            color: var(--text-nav);
            background-color: var(--background-nav);
            border-radius: 0.5em 0.5em 0 0;

            padding: 0.25em;
            align-items: center;
        }
        .wordlist-header > div {
            width: 100%;
            padding: 0 0.5em;
            
            align-items: center;
            justify-content: space-between;
        }
        .wordlist-footer {
            color: var(--text-nav);
            background-color: var(--background-nav);
            border-radius: 0em 0em 0.5em 0.5em;

            padding: 0.25em;

            align-items: center;
            justify-content: center;
        }
        .wordlist-footer > p {
            font-size: 0.8em;
        }
        #wordlist-difficulty {
            color: var(--background-nav);
            background-color: var(--text-nav);
            border-radius: 1.0em;

            padding: 0em 0.5em;
            font-size: 0.8em;
        }
        #wordlist-content {
            color: var(--text-dark);

            display: flex;
            padding: 0.5em;

            /* overflow-y: scroll; */
            flex-flow: row wrap;
            justify-content: center;
            align-content: flex-start;
            gap: 0.25em;
        }
        .wordlist-item {
            border-radius: 1em;
            display: inline-block;
            /* margin: 0.25em; */
            padding: 0.25em 0.5em;
            /* font-size: 0.8em; */
        }
        .highlighted {
            opacity: 0.3;
            text-decoration: line-through;
        }

        .wordlist-title {
            color: var(--text-nav);
            background-color: var(--background-nav);
            /* border-radius: 0.5em; */

            width: 100%;
            padding: 0.25em;

            align-items: center;
            justify-content: center;
        }
        .wordlist-title > p {
            /* font-size: 0.8em; */
        }

        /**** SETTINGS ****/

        #settings {
            background-color: var(--background-inset);
            border-radius: 0.5em;
            filter: drop-shadow(var(--popout-shadow));
            /* overflow: scroll; */

            width: 100%;
        }
        .settings-wrapper {
            padding: 0.5em;
            gap: 0.5em;
        }
        .settings-info {
            gap: 0.2em;
        }
        .settings-info > .flex-row {
            align-items: baseline;
        }
        .settings-title {
            color: var(--text-medium);
            padding: 0 0.5em;
            width: 5em;
            font-size: 0.6em;
            text-align: right;
        }
        .settings-actions {
            justify-content: space-around;
        }
        .settings-button {
            cursor: pointer;
            color: var(--text-nav);
            background-color: var(--background-nav);
            border-radius: 1em;

            width: 7em;
            padding: 0.25em 0.15em;
            text-align: center;
        }
        .settings-button:hover {
            text-decoration: underline;
        }

        #settings-vocab-select {
            cursor: pointer;
            color: var(--text-dark);
            background-color: var(--background-nav-unselected);
            border: 2px solid var(--background-nav-selected);
            border-radius: 0.2em;
            
            padding: 0.2em;
            font-size: 0.8em;

            flex-grow: 1;
            min-width: 0; /* required for having smaller width than longest <option> */
            text-overflow: ellipsis;
        }
        .settings-options-wrapper {
            flex-grow: 1;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-around;
        }
        .settings-option {
            cursor: pointer;
            color: var(--text-medium);
            background-color: var(--background-nav-unselected);
            /* border: 2px solid var(--text-medium); */
            border-radius: 1em;
            width: 5em;
            padding: 0.2em;
            font-size: 0.8em;
            text-align: center;
        }
        .settings-option-selected {
            color: var(--text-nav);
            background-color: var(--background-nav-selected);
            border: none;
        }

        /**** WORDSEARCH ****/
        
        #wordsearch-click-area {
            /* border: 1px solid red; */
            width: 100%;
            height: 100%;
            justify-content: space-around;
        }
        .wordsearch-tile {
            /* border: 1px solid blue; */
            position: relative;
            width: 1.0em;
            height: 1.0em;

            display: flex;
            align-items: center;
            justify-content: center;
        }
        .caterpillar {
            --radius: 0.7em;
            --offset: calc(-1 * var(--radius));
            pointer-events: none;
            background-color: var(--background-dark);
            border-radius: var(--radius);
            opacity: 0.3;

            display: inline-block;
            position: absolute;
            padding: var(--radius);
            width: 0;
            height: 0;
            top: 1em;
            left: 1em;
            transform-origin: var(--radius) var(--radius);
            transform: translate(var(--offset),var(--offset)) rotate(0);
        }
        #cursor-caterpillar {
            visibility: hidden; /* start out invisible; only show while click-dragging */
        }

        /**** LOADING SCREEN ****/

        #player-loading-screen {
            background-color: var(--background-inset);

            position: absolute;
            padding: 0.25em;
            width: calc(100% - 0.25em - 0.25em);
            height: calc(100% - 0.25em - 0.25em);
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);

            gap: 2.0em;
            align-items: center;
        }
        .loading-animation-track {
            display: inline-block;
            position: relative;
            width: 2em;
        }
        .loading-icon-full, .loading-icon-empty {
            display: inline-block;
            position: absolute;
            width: 1.0em;
            height: 1.0em;
            transform: translate(-50%,-50%) rotate(45deg);
        }
        .loading-icon-full {
            background-color: var(--background-nav);
            left: 0%;

            animation: loading-left 1.5s ease infinite;
        }
        .loading-icon-empty {
            background-color: var(--background-inset);
            border: 0.1em solid var(--background-nav);
            left: 100%;

            animation: loading-right 1.5s ease infinite;
        }
        /* loading animation: 2 diamonds slide past each other, changing which one is on top */
        @keyframes loading-left {
            /* z-index changes at midpoint between keyframes, use fractional keyframes to set midpoint where diamonds don't overlap */
            0%   { left:0%;   z-index:1; }
            49%  { left:100%; z-index:1; }
            50%  { left:100%; z-index:2; }
            99%  { left:0%;   z-index:2; }
            100% { left:0%;   z-index:1; }
        }
        @keyframes loading-right {
            /* z-index changes at midpoint between keyframes, use fractional keyframes to set midpoint where diamonds don't overlap */
            0%   { left:100%; z-index:2; }
            49%  { left:0%;   z-index:2; }
            50%  { left:0%;   z-index:1; }
            99%  { left:100%; z-index:1; }
            100% { left:100%; z-index:2; }
        }

        /* mobile-first styling for better load times on less-powerful devices */
        /* media queries must come after the things they modify */
        @media (max-aspect-ratio: 5/4) { /* mobile mode */
            /* [none] */
        }
		@media (min-aspect-ratio: 5/4) { /* desktop mode */
            :root {
                --title-font-size: 1.0em;
                --nav-height: calc(1.5 * var(--fluid-font-size)); /* ref height for content anchors; 1.0em text + 2*0.25em padding */

                /* 50% width < x < 100% height, min 11em */
                --wordsearch-width: max( min(50vw, calc(100vh - var(--nav-height) - 2 * var(--content-pad))), calc(11 * var(--fluid-font-size)) );
            }
			.flex-adapt {
				flex-direction: row;
                align-items: normal;
				justify-content: center;
			}
            .flex-adapt-reverse {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            #content {
                flex-direction: row;
                align-items: center;
                justify-content: center;
            }
            #wordlist-wrapper {
                width: 15em;
                height: var(--wordsearch-width);
                /* flex-direction: column-reverse; */
                justify-content: start;
            }
            .wordlist-item {
                display: block;
            }
            .settings-wrapper {
                font-size: 0.8em;
            }
		}



        /**** DEBUG ****/

        .marker {
            border: 1px solid green;

            display: inline-block;
            position: absolute;
            width: var(--wordsearch-tile-width);
            height: var(--wordsearch-tile-width);
            transform: translate(-50%,-50%);
        }
		
	</style>
</head>
<body>

<div id='nav-bar'>
    <h1 id='nav-title'>Chukchansi Wordsearch</h1>
    <nav id='nav-menu' role='navigation'>
        <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-linecap='round' stroke-linejoin='round' width='24' height='24' stroke-width='1.25' style='width:100%;height:100%;pointer-events:none;'>
            <path d='M5 8l14 0'></path>
            <path d='M5 12l14 0'></path>
            <path d='M5 16l14 0'></path>
        </svg>
        <ul id='nav-dropdown' class='flex-row'>
            <div class='flex-col'>
                <!-- <li><a>Home</a></li> -->
                <p class='nav-greyed-out'>Home</p>
            </div>
            <div class='flex-col'>
                <li><a href='speaking-dictionary'>Speaking Dictionary</a></li>
                <li><a href='pdf-dictionary'>PDF Dictionary</a></li>
                <li><a href='stories'>Story Reader</a></li>
                <li><a href='wordsearch'>Wordsearch</a></li>
            </div>
        </ul>
    </nav>
</div>
<div id='content' class='flex-adapt'>
    <div id='wordlist-wrapper' class='flex-col'>
        <div id='wordlist' class='flex-col'>
            <div class='flex-col wordlist-header'>
                <!-- <p>Hawitmi Siksikaʔ Limeek’ataʔ</p> -->
                <div class='flex-row'>
                    <p id='wordlist-progress'>0/0</p>
                    <div class='flex-sep'></div>
                    <p id='wordlist-difficulty'>Hard</p>
                </div>
            </div>
            <div id='wordlist-content'>
                <p class='wordlist-item'>Word 1</p>
                <p class='wordlist-item highlighted'>Word 2</p>
            </div>
        </div>
        <div id='settings' class='flex-col'>
            <div id='settings-header-title' class='flex-col wordlist-header'>
                <p>Wordsearch Settings</p>
            </div>
            <div id='settings-current' class='flex-col settings-wrapper'>
                <div class='flex-col settings-info'>
                    <div class='flex-row'>
                        <p class='settings-title'>Vocab</p>
                        <p id='settings-info-vocab' class='settings-info-content'>Hawitmi Siksikaʔ Limeek’ataʔ</p>
                    </div>
                    <div class='flex-row'>
                        <p class='settings-title'>Grid</p>
                        <p id='settings-info-grid' class='settings-info-content'>11 x 11</p>
                    </div>
                    <div class='flex-row'>
                        <p class='settings-title'>Difficulty</p>
                        <p id='settings-info-difficulty' class='settings-info-content'>Hard</p>
                    </div>
                </div>
                <div class='flex-row settings-actions'>
                    <div class='settings-button' onclick='controller.newGame()'>Regenerate</div>
                    <div class='settings-button' onclick='document.getElementById("settings-header-title").innerHTML="New Wordsearch";document.getElementById("settings-current").style.display="none";document.getElementById("settings-new").style.display=""'>New Game</div>
                </div>
            </div>
            <div id='settings-new' class='flex-col settings-wrapper' style='display: none;'>
                <div class='flex-col settings-info'>
                    <div class='flex-row'>
                        <p class='settings-title'>Vocab</p>
                        <!-- <p id='settings-info-vocab' class='settings-info-content'>[dropdown menu]</p> -->
                        <select id='settings-vocab-select' onchange='newGameSetVocab(document.getElementById("settings-vocab-select").value)'>
                            <!-- <option value='0,vocab'>Vocab: Siksikaʔ Limeek’ataʔ</option>
                            <option value='1,vocab'>Vocab: Kaʔyuʔun Shashaʔ</option>
                            <option value='2,vocab'>Vocab: ʔuplalliʔ ʔamaʔ yoʔ Deemay’suʔ</option>
                            <option value='3,vocab'>Vocab: Shelel’ Shilithanaʔ</option>
                            <option value='0,rand'>Random: Siksikaʔ Limeek’ataʔ</option>
                            <option value='1,rand'>Random: Kaʔyuʔun Shashaʔ</option>
                            <option value='2,rand'>Random: ʔuplalliʔ ʔamaʔ yoʔ Deemay’suʔ</option>
                            <option value='3,rand'>Random: Shelel’ Shilithanaʔ</option> -->
                            <option value='0,vocab'>Vocab: How Stinkbug Became Black</option>
                            <option value='1,vocab'>Vocab: Why Coyote's Eyes are the Best</option>
                            <option value='2,vocab'>Vocab: Dove and Hummingbird Race</option>
                            <option value='3,vocab'>Vocab: A Rock to be Jumped</option>
                            <option value='0,rand'>Random: How Stinkbug Became Black</option>
                            <option value='1,rand'>Random: Why Coyote's Eyes are the Best</option>
                            <option value='2,rand'>Random: Dove and Hummingbird Race</option>
                            <option value='3,rand'>Random: A Rock to be Jumped</option>
                            <option value='0,grammar'>Grammar: -mi Words</option>
                        </select>
                    </div>
                    <div class='flex-row'>
                        <p class='settings-title'>Grid</p>
                        <div class='flex-row settings-options-wrapper'>
                            <!-- <div id='settings-gridsize-8' class='settings-option' onclick='newGameSetGridsize(8)'>8x8</div> -->
                            <div id='settings-gridsize-11' class='settings-option settings-option-selected' onclick='newGameSetGridsize(11)'>11x11</div>
                            <div id='settings-gridsize-13' class='settings-option' onclick='newGameSetGridsize(13)'>13x13</div>
                        </div>
                    </div>
                    <div class='flex-row'>
                        <p class='settings-title'>Difficulty</p>
                        <div class='flex-row settings-options-wrapper'>
                            <div id='settings-difficulty-0' class='settings-option' onclick='newGameSetDifficulty(0)'>Easy</div>
                            <div id='settings-difficulty-1' class='settings-option' onclick='newGameSetDifficulty(1)'>Medium</div>
                            <div id='settings-difficulty-2' class='settings-option settings-option-selected' onclick='newGameSetDifficulty(2)'>Hard</div>
                        </div>
                    </div>
                </div>
                <div class='flex-row settings-actions'>
                    <div class='settings-button' onclick='hideNewGamePanel();controller.applyNewGameSettings();controller.newGame()'>Create</div>
                    <div class='settings-button' onclick='hideNewGamePanel()'>Cancel</div>
                </div>
            </div>
        </div>
    </div>

    <div id='wordsearch-wrapper'>
        <div id='wordsearch-click-area' class='flex-col'></div>
        <div id='cursor-caterpillar' class='caterpillar'></div>
    </div>
</div>



<!-- load wordbank compiler (builds wordbanks from database) -->
<script type='text/javascript' src="script/vocab.js"></script>
<!-- load story data -->
<script type='text/javascript' src="source/story-0/sox-siksikaʔ-data-annotated.js"></script>
<script type='text/javascript' src="source/story-1/kaʔyuʔun-shashaʔ-data-annotated.js"></script>
<script type='text/javascript' src="source/story-2/ʔuplalliʔ-deemaysuʔ-data-annotated.js"></script>
<script type='text/javascript' src="source/story-3/shelel'-shilithanaʔ-data-annotated.js"></script>

<script type='text/javascript'>

    //// WAVE 3 ////

    // 1.5 hrs: set up fluid typography and mobile-friendly responsive layout
    // 1.0 hrs: add wordsearch UI
    // 1.0 hrs: dev wordsearch data structure
    // 1.5 hrs: build sox-siksika wordlist, dev algorithm
    // 5.0 hrs: try multiple wordsearch gen algorithms, fully impl wordsearch gen
    // 1.5 hrs: add list of words to UI
    // 2.0 hrs: add mouse functionality, make fully playable on pc
    // 1.0 hrs: add touch support
    // 1.0 hrs: testing and UI design planning
    // 3.5 hrs: add word selection "caterpillar" while dragging, improve wordlist UI
    // 1.0 hrs: highlight words with caterpillars once they're found
    // 1.5 hrs: admin stuff and research prepping for new repo to go live
    // 1.5 hrs: auto gen wordbanks from stories
    // 2.0 hrs: switch to controller architecture for future scaleability
    // 0.5 hrs: fix caterpillars not resetting on new game
    // 1.0 hrs: update readme, github admin stuff
    // 1.0 hrs: apply SEO to all main site pages
    // 5.0 hrs: generalize vocab wordlist format
    // 0.5 hrs: print difficulties demo
    // 0.5 hrs: fix wordsearch breaking after file name standardization; add failsafe for future
    // 1.5 hrs: admin stuff, nav standardization
    // 4.0 hrs: make ui fully dynamic, misc bug fixes
    // 2.0 hrs: create story vocab lists, dynamic wordbanks/wordlists
    // 4.0 hrs: UI update, difficulty selection prep
    // 5.0 hrs: settings and new game ui design
    // 4.5 hrs: finish new game UI and add interactivity
    // 3.0 hrs: compile vocab lists

    //// dropdown menu: https://stackoverflow.com/questions/647282/is-there-an-onselect-event-or-equivalent-for-html-select



    // CSS var manipulation
    const CSSVars = {
        get : (k) => getComputedStyle(document.documentElement).getPropertyValue(k),
        set : (k,v) => document.documentElement.style.setProperty(k,v)
    };
    
    // DOM anchors
    const navTitle = document.getElementById('nav-title');
    const wordlist = document.getElementById('wordlist-content');
    const progress = document.getElementById('wordlist-progress');
    const settingsCurrent = document.getElementById('settings-current'); // used by button onclicks
    const settingsNew = document.getElementById('settings-new');
    const settingsVocabSelect = document.getElementById('settings-vocab-select');
    const wordsearch = document.getElementById('wordsearch-click-area');
    const wordsearchContainer = document.getElementById('wordsearch-wrapper');
    const cursorCaterpillar = document.getElementById('cursor-caterpillar');

    const randInt = (min,max) => Math.floor(Math.random() * (max-min+1)) + min;
    const ALPHABET = `ABCDEFGHIJKLMNOPSTUVWXY'ʔ`; // chukchansi adds glottal stops ['ʔ], and doesn't have [qrz]

    // const DIRECTIONS = [ 
    //     [0,1],[1,0],[0,-1],[-1,0],
    //     [1,1],[-1,1],[-1,-1],[1,-1]
    // ];

    // directions are pairs of [dx,dy]
    const DIRECTIONS_EASY = [
        [0,1],[1,0] // top2bot or left2right
    ];
    const DIRECTIONS_MED = [
        [0,1],[1,0],[0,-1],[-1,0], // any vertical or horizontal
        [1,1],[-1,1] // top2bot diagonals
    ];
    const DIRECTIONS_HARD = [
        [0,1],[1,0],[0,-1],[-1,0], // any vertical or horizontal
        [1,1],[-1,1],[-1,-1],[1,-1] // any diagonal
    ];

    const WORDLEN_EASY = 7;
    const WORDLEN_MED = 10;
    const WORDLEN_HARD = 15;



    // gamestate controller
    let controller = {
        // constants and settings
        MIN_SIDELEN : 11,
        // MIN_SIDELEN : 10,
        minWordlen : 3,
        maxWordlen : 10,
        directions : DIRECTIONS_HARD,

        // word data
        wordlist : [], // actual wordlist, set by newGame(targetWordlist); may be diff than target if unable to place all words
        wordData : [], // gamestate data linked to words; coindexed with wordlist
        failedWords : [], // empty unless algorithm can't place a word after 1000 attempts
        numFound : () => {
            let n = 0;
            for (let word of controller.wordData)
                if (word.found)
                    n++;
            return n;
        },
        allFound : () => controller.numFound() == controller.wordData.length,

        // gamestate interaction
        newGameSettings : {
            vocab : 0, // id of vocab list
            random : false, // whether to use curated vocab list or randomly select from story
            gridsize : 11, // sidelength of grid
            difficulty : 1 // 0=easy, 1=medium, 2=hard
        },
        applyNewGameSettings : () => {
            if (controller.newGameSettings.type === 'vocab') {
                controller.wordlist = storyVocabWordlists[Object.keys(storyVocabWordlists)[controller.newGameSettings.vocab]];
                document.getElementById('settings-info-vocab').innerHTML = Object.keys(storyVocabWordlists)[controller.newGameSettings.vocab];
            } else if (controller.newGameSettings.type === 'rand') {
                controller.wordlist = storyRandomWordlists[Object.keys(storyRandomWordlists)[controller.newGameSettings.vocab]];
                document.getElementById('settings-info-vocab').innerHTML = Object.keys(storyRandomWordlists)[controller.newGameSettings.vocab];
            } else if (controller.newGameSettings.type === 'grammar') {
                controller.wordlist = vocabWordlists[Object.keys(vocabWordlists)[controller.newGameSettings.vocab]];
                document.getElementById('settings-info-vocab').innerHTML = Object.keys(vocabWordlists)[controller.newGameSettings.vocab];
            } else {
                console.log(`vocab list ${controller.newGameSettings.vocab}`);
            }
            controller.maxWordlen = controller.newGameSettings.gridsize;
            document.getElementById('settings-info-grid').innerHTML = `${controller.newGameSettings.gridsize} x ${controller.newGameSettings.gridsize}`;
            controller.directions = [DIRECTIONS_EASY, DIRECTIONS_MED, DIRECTIONS_HARD][controller.newGameSettings.difficulty];
            document.getElementById('settings-info-difficulty').innerHTML = ['Easy','Medium','Hard'][controller.newGameSettings.difficulty];
        },
        newGame : () => {
            // clear any in-progress user inputs
            moveEnd();
            // clear previous game's caterpillars
            for (let word of controller.wordData) {
                if (wordsearchContainer.contains(word.caterpillar)) {
                    wordsearchContainer.removeChild(word.caterpillar);
                }
            }
            // reset word data
            controller.wordData = [];
            for (let i = 0; i < controller.wordlist.length; i++) {
                controller.wordData.push({
                    found : false,
                    caterpillar : document.createElement('div')
                });
                controller.wordData[i].caterpillar.classList.add('caterpillar');
            }
            // gen new wordsearch
            getWordsearch(controller.newGameSettings.gridsize, controller.wordlist);
            // initial render
            renderWordsearch(controller.grid);
        },

        // gamestate
        grid : [], // current game board
        stringFrom : (r1,c1,r2,c2) => {
            const dr = Math.abs(r2-r1);
            const dc = Math.abs(c2-c1);
            let s = '';
            if (dr == 0) { // vertical
                if (c2 > c1) {
                    for (let c = c1; c <= c2; c++) s = s + controller.grid[r1][c]; // left-to-right
                } else {
                    for (let c = c1; c >= c2; c--) s = s + controller.grid[r1][c]; // right-to-left
                }
            } else if (dc == 0) { // horizontal
                if (r2 > r1) {
                    for (let r = r1; r <= r2; r++) s = s + controller.grid[r][c1]; // top-to-bottom
                } else {
                    for (let r = r1; r >= r2; r--) s = s + controller.grid[r][c1]; // bottom-to-top
                }
            } else if (dr == dc) { // diagonal
                if (r2 > r1) {
                    if (c2 > c1) {
                        for (let delta = 0; delta <= dr; delta++) s = s + controller.grid[r1+delta][c1+delta]; // top-left to bot-right
                    } else {
                        for (let delta = 0; delta <= dr; delta++) s = s + controller.grid[r1+delta][c1-delta]; // top-right to bot-left
                    }
                } else {
                    if (c2 > c1) {
                        for (let delta = 0; delta <= dr; delta++) s = s + controller.grid[r1-delta][c1+delta]; // bot-left to top-right
                    } else {
                        for (let delta = 0; delta <= dr; delta++) s = s + controller.grid[r1-delta][c1-delta]; // bot-right to top-left
                    }
                }
            } else {
                console.log(`FAIL Coords do not give valid string.`);
                // return undefined;
            }
            // console.log(s);
            return s;
        }
    };

    // new game interaction
    function newGameSetVocab (raw) {
        const [id,type] = raw.split(',');
        controller.newGameSettings.vocab = id ?? 0;
        // controller.newGameSettings.random = (list === 'rand');
        controller.newGameSettings.type = type;
        console.log(controller.newGameSettings.vocab,controller.newGameSettings.type);
    }
    function newGameSetGridsize (size) {
        if (size < 3) {
            console.warn('ERR Wordsearch grid cannot be smaller than 4x4 (max word len 3).');
            size = 3;
        }
        controller.newGameSettings.gridsize = size;
        // render UI update
        // if (size === 8) document.getElementById('settings-gridsize-8').classList.add('settings-option-selected');
        // else document.getElementById('settings-gridsize-8').classList.remove('settings-option-selected');
        if (size === 11) document.getElementById('settings-gridsize-11').classList.add('settings-option-selected');
        else document.getElementById('settings-gridsize-11').classList.remove('settings-option-selected');
        if (size === 13) document.getElementById('settings-gridsize-13').classList.add('settings-option-selected');
        else document.getElementById('settings-gridsize-13').classList.remove('settings-option-selected');
    }
    function newGameSetDifficulty (difficulty) {
        if (difficulty !== 0 && difficulty !== 1 && difficulty !== 2) {
            console.error('ERR Wordseach difficulty must be 0=easy, 1=medium, or 2=hard.');
            return;
        }
        controller.newGameSettings.difficulty = difficulty;
        // render UI update
        if (difficulty === 0) document.getElementById('settings-difficulty-0').classList.add('settings-option-selected');
        else document.getElementById('settings-difficulty-0').classList.remove('settings-option-selected');
        if (difficulty === 1) document.getElementById('settings-difficulty-1').classList.add('settings-option-selected');
        else document.getElementById('settings-difficulty-1').classList.remove('settings-option-selected');
        if (difficulty === 2) document.getElementById('settings-difficulty-2').classList.add('settings-option-selected');
        else document.getElementById('settings-difficulty-2').classList.remove('settings-option-selected');
    }
    function hideNewGamePanel () {
        document.getElementById("settings-header-title").innerHTML="Wordsearch Settings";
        document.getElementById("settings-current").style.display="";
        document.getElementById("settings-new").style.display="none"
    }

    



    


    



    
    function tryPlaceWord (word) {
        function tryPlace () {
            const [dr,dc] = controller.directions[randInt(0,controller.directions.length-1)];
            const rMin = (dr<0) ? word.length-1 : 0;
            const rMax = (dr<=0) ? controller.grid.length-1 : controller.grid.length-word.length;
            const cMin = (dc<0) ? word.length-1 : 0;
            const cMax = (dc<=0) ? controller.grid.length-1 : controller.grid.length-word.length;
            // console.log(`dir(${dr},${dc}), sidelen ${controller.grid.length} wordlen ${word.length}, r on [${rMin},${rMax}], c on [${cMin},${cMax}]`);
            let rStart = r = randInt(rMin,rMax);
            let cStart = c = randInt(cMin,cMax);
            for (let i = 0; i < word.length; i++) {
                // console.log(`i ${i}, side ${controller.grid.length}, rc (${r},${c})`);
                if (controller.grid[r][c] != word[i] && controller.grid[r][c] != '.') {
                    return [];
                } else {
                    r += dr;
                    c += dc;
                }
            }
            return [rStart,cStart,dr,dc];
        }
        let breakout = 1000;
        while (breakout-- > 0) {
            const [rStart,cStart,dr,dc] = tryPlace();
            if (rStart == undefined) continue;
            let r = rStart;
            let c = cStart;
            for (let i = 0; i < word.length; i++) {
                controller.grid[r] = controller.grid[r].slice(0,c) + word[i] + controller.grid[r].slice(c+1);
                r += dr;
                c += dc;
            }
            return true;
        }
        console.error(`ERR Could not place word "${word}" in grid after 1000 tries.`);
        console.log(controller.grid);
        controller.failedWords.push(word);
        return false;
    }
    function getWordsearch (sidelen,words=[]) {
        sidelen = Math.max(sidelen, ...words.map(w=>w.length+1)); // sidelen is longest word + 1, but no less than target sidelen
        words = words.map(w=>w.toUpperCase()).sort((a,b)=>a.length<b.length);
        function resetGrid () { // init empty grid
            controller.grid = [];
            for (let r = 0; r < sidelen; r++) {
                controller.grid.push('.'.repeat(sidelen));
            }
        }
        function tryFillGrid () { // place words in grid longest first, shortest last
            controller.failedWords = [];
            for (let word of words) {
                tryPlaceWord(word);
            }
        }
        // run first pass
        resetGrid();
        tryFillGrid();
        // if first pass fails to place a word, it gets a second chance
        if (controller.failedWords.length > 0) {
            console.warn(`Unable to find valid placement for the following word(s) after 1000 tries:`, controller.failedWords);
            console.warn(`Regenerating...`);
            resetGrid();
            tryFillGrid();
            if (controller.failedWords.length > 0) {
                console.error(`Unable to find valid placement for the following word(s) after 1000 tries:`, controller.failedWords);
                console.error(`Generation fail. Wordlist may not be suitable for a grid of this size.`);
            } else {
                console.warn(`Regeneration successful.`);
            }
        }
        // fill in remaining blanks with random chars
        for (let row = 0; row < sidelen; row++) {
            let gridrow = '';
            for (let col = 0; col < sidelen; col++) {
                if (controller.grid[row][col] == '.') {
                    gridrow = gridrow + ALPHABET[randInt(0,ALPHABET.length-1)];
                } else {
                    gridrow = gridrow + controller.grid[row][col];
                }
            }
            controller.grid[row] = gridrow;
        }

        // console.log(controller.grid);
    }

    function renderWordsearch (grid) {
        const rows = grid[0].length;
        const cols = grid.length;

        let wordlistStr = '';
        for (let i = 0; i < controller.wordlist.length; i++) {
            wordlistStr += `<p id='word-${i}' class='wordlist-item'>${controller.wordlist[i]}</p>`;
        }

        let wordsearchStr = '';
        for (let r = 0; r < rows; r++) {
            wordsearchStr += `<div class='flex-row' style='justify-content:space-around;'>`;
            for (let c = 0; c < cols; c++) {
                wordsearchStr += `<div class='wordsearch-tile'>${grid[r][c]}</div>`;
                // wordsearchStr += `<div class='wordsearch-tile' onclick='console.log("(${r},${c}) ${grid[r][c]}")'>${grid[r][c]}</div>`;
            }
            wordsearchStr += `</div>`;
        }

        progress.innerHTML = `${controller.numFound()}/${controller.wordData.length}`;
        wordlist.innerHTML = wordlistStr;
        wordsearch.innerHTML = wordsearchStr;

    }

    let rDragStart = -1;
    let cDragStart = -1;
    let dragging = false;
    function moveStart (e,isTouch) {
        if (isTouch) e.preventDefault(); // prevent touch scrolling
        const x = (isTouch) ? e.touches[0].clientX : e.clientX;
        const y = (isTouch) ? e.touches[0].clientY : e.clientY;

        const b = wordsearch.getBoundingClientRect();
        rDragStart = Math.floor(controller.grid.length * (y-b.top)/b.height);
        cDragStart = Math.floor(controller.grid.length * (x-b.left)/b.width);
        dragging = true;
        console.log(`start drag from (${rDragStart},${cDragStart})`);

        cursorCaterpillar.style.visibility = 'visible';
        cursorCaterpillar.style.width = '0';
        cursorCaterpillar.style.top = `calc(var(--wordsearch-pad) + ${0.5+rDragStart} * var(--wordsearch-tile-width))`;
        cursorCaterpillar.style.left = `calc(var(--wordsearch-pad) + ${0.5+cDragStart} * var(--wordsearch-tile-width))`;
    }
    function moveEnd (e) {
        cursorCaterpillar.style.visibility = 'hidden';
        rDragStart = -1;
        cDragStart = -1;
        dragging = false;
    }
    function move (e,isTouch) {
        if (dragging) {
            if (isTouch) e.preventDefault(); // prevent touch scrolling
            const x = (isTouch) ? e.touches[0].clientX : e.clientX;
            const y = (isTouch) ? e.touches[0].clientY : e.clientY;

            const b = wordsearch.getBoundingClientRect();
            const rDragEnd = Math.floor(controller.grid.length * (y-b.top)/b.height);
            const cDragEnd = Math.floor(controller.grid.length * (x-b.left)/b.width);
            const dr = Math.abs(rDragEnd - rDragStart);
            const dc = Math.abs(cDragEnd - cDragStart);
            // console.log(`(${rDragStart},${cDragStart}) -> (${rDragEnd},${cDragEnd}) drdc(${dr},${dc})`);

            const tileWidth = b.width / controller.grid.length;
            // console.log(tileWidth);
            const xDragStart = (0.5+cDragStart) * tileWidth;
            const yDragStart = (0.5+rDragStart) * tileWidth;
            const dx = (x) - (xDragStart+b.left);
            const dy = (y) - (yDragStart+b.top);
            const dist = Math.sqrt(dx*dx + dy*dy); // measured in px since caterpillar doesn't snap to tiles; doesn't need to scale dynamically since caterpillar disappears
            const angle = Math.atan2(dy,dx);
            cursorCaterpillar.style.width = `calc(var(--wordsearch-pad) + var(--wordsearch-tile-width) + ${dist}px)`;
            cursorCaterpillar.style.transform = `translate(var(--offset),var(--offset)) rotate(${angle}rad)`;
            // console.log(`x ${xDragStart+b.left}->${x}, dxdy (${dx},${dy}) theta ${(180/2/Math.PI * angle).toFixed(1)}deg`);

            if (dr == 0 || dc == 0 || dr == dc) {
                // if on a straight or diagonal, check if current string is in wordlist
                const wordsearchStr = controller.stringFrom(rDragStart,cDragStart,rDragEnd,cDragEnd);
                for (let i = 0; i < controller.wordlist.length; i++) {
                    if (controller.wordlist[i].toUpperCase() == wordsearchStr) {
                        // mark word as found
                        console.log(`Found word "${controller.wordlist[i]}"!`);
                        document.getElementById(`word-${i}`).classList.add('highlighted');
                        controller.wordData[i].found = true;
                        // position caterpillar over word
                        const dx = cDragEnd - cDragStart;
                        const dy = rDragEnd - rDragStart;
                        const dist = Math.sqrt(dx*dx + dy*dy); // measured in number of tiles; caterpillars must scale dynamically
                        const angle = Math.atan2(dy,dx);
                        controller.wordData[i].caterpillar.style.width = `calc(${1+dist} * var(--wordsearch-tile-width))`;
                        controller.wordData[i].caterpillar.style.transform = `translate(var(--offset),var(--offset)) rotate(${angle}rad)`;
                        controller.wordData[i].caterpillar.style.top = `calc(var(--wordsearch-pad) + ${0.5+rDragStart} * var(--wordsearch-tile-width))`;
                        controller.wordData[i].caterpillar.style.left = `calc(var(--wordsearch-pad) + ${0.5+cDragStart} * var(--wordsearch-tile-width))`;
                        wordsearchContainer.appendChild(controller.wordData[i].caterpillar);
                        // update progress counter
                        progress.innerHTML = `${controller.numFound()}/${controller.wordData.length}`;
                        if (controller.allFound()) {
                            console.log('Congratulations, you found all the words!');
                        }
                        // if word was found, can stop tracking current click-drag
                        cursorCaterpillar.style.visibility = 'hidden';
                        rDragStart = -1;
                        cDragStart = -1;
                        dragging = false;
                    }
                }
            }
        }
    }
    // mouse controls
    wordsearch.addEventListener('mousedown', e => moveStart(e,false));
    wordsearch.addEventListener('mousemove', e => move(e,false));
    window.addEventListener('mouseup', e => moveEnd(e));
    // touch controls
    wordsearch.addEventListener('touchstart', e => moveStart(e,true));
    wordsearch.addEventListener('touchmove', e => move(e,true));
    window.addEventListener('touchend', e => moveEnd(e));

    // window.addEventListener('resize', e => {
    //     navTitle.innerHTML = (window.innerWidth < window.innerHeight) ? 'Chk Wordsearch' : 'Chukchansi Wordsearch';
    // });
    // navTitle.innerHTML = (window.innerWidth < window.innerHeight) ? 'Chk Wordsearch' : 'Chukchansi Wordsearch';

    //////////////////////
    
    // init //

    // build word bank of unique words from stories
    let stories = [
        story_sox_siksikaʔ,
        story_kaʔyuʔun_shashaʔ,
        story_ʔuplalliʔ_deemaysuʔ,
        story_shelel_shilithanaʔ
    ];
    const storyWordbanks = stories.map(storyData => {
        if (typeof storyData == 'undefined') {
            console.error('Invalid story data.');
            return undefined;
        }

        let wordbank = new Set();
        for (let i = 0; i < storyData.timestampsBySentence.length; i+=3) {
            const timestamp = storyData.timestampsBySentence[i];
            const textCHK = storyData.timestampsBySentence[i+1];
            const textENG = storyData.timestampsBySentence[i+2];
            // stories may have ’ instead of ' for formatting; make the replacement, then scrub non-alphabetic chars
            const words = textCHK.replaceAll("’","'").replaceAll(/[^a-zA-Z'ʔ ]/g,'').split(' ');
            for (let word of words) {
                wordbank.add(word.toLowerCase());
            }
        }
        // console.log(wordbank);

        return wordbank;
    });

    // compile word banks
    function getWordlist (wordbank, numWords, minLen=3, maxLen=8) {
        let words = [];
        for (let word of wordbank.keys()) words.push(word);

        let wordset = new Set();
        let breakout = 1000;
        while (--breakout > 0 && wordset.size < numWords) {
            let word = words[randInt(0,words.length-1)];
            if (word.length >= minLen && word.length <= maxLen) {
                wordset.add(word);
            }
        }
        // console.log(wordset);

        if (wordset > 0) {
            console.error(`Wordbank did not contain sufficient words matching settings.`);
            return [];
        } else {
            let wordlist = [];
            for (let word of wordset.keys()) wordlist.push(word);
            return wordlist;
        }
    }

    

    // let wordbank_sox_siksika = new Set();
    // let wordlist_sox_siksika_gen;
    // if (typeof story_sox_siksikaʔ !== 'undefined') {    
    //     for (let i = 0; i < story_sox_siksikaʔ.timestampsBySentence.length; i+=3) {
    //         const timestamp = story_sox_siksikaʔ.timestampsBySentence[i];
    //         const textCHK = story_sox_siksikaʔ.timestampsBySentence[i+1];
    //         const textENG = story_sox_siksikaʔ.timestampsBySentence[i+2];
    //         // stories may have ’ instead of ' for formatting; make the replacement, then scrub non-alphabetic chars
    //         let words = textCHK.replaceAll("’","'").replaceAll(/[^a-zA-Z'ʔ ]/g,'').split(' ');
    //         for (let word of words) {
    //             wordbank_sox_siksika.add(word.toLowerCase());
    //         }
    //     }
    //     wordlist_sox_siksika_gen = getWordlist(wordbank_sox_siksika, 10, controller.minWordlen, controller.maxWordlen);
    // } else {
    //     console.error('File not found. Defaulting to static wordlist.');
    // }
    // console.log(wordbank_sox_siksika);
    
    // default curated word list in case things go wrong
    const storyVocabWordlists = Object.freeze({
        "How Stinkbug Became Black"             : ["Sox","Siksikaʔ","ʔoshto","woodiyga","namix","ʔutuytaʔ","henew","t'uluntaʔ","shaapintaʔ","limeek'am"],
            // Skunk, Stinkbug, fire, dance, friend, pushed, some, burned, extinguished, became black
        "Why Coyote's Eyes are the Best"        : ["Lopis","Kaʔyuʔ","shashaaʔan","wakaayaw","wech'eeta","ch'edmat","gayis","bajxaʔli","hoych'it","taʔishtaʔ"],
            // Fish, Coyote, eyes, river, stick, think, good, bad, want, see
        "Dove and Hummingbird Race Each Other"  : ["ʔuplalliʔ","deemay'suʔ","baanewshit","hoy'nit","ʔayax","wentaw","hayk'itaw","hoyonhiy'","ch'awit","hidyaʔ"],
            // Dove, Hummingbird, race each other, fly, fast, start, finish (line), wing, win, everybody
        "A Rock to be Jumped"                   : ["shelel'","shil't'eʔ","hiky'eʔ","lihmit","bohloʔ","xishweʔ","texeetan'","noneeʔi","mokeela","peeli"]
            // rock, jump, play, run, grow, scratch, hurt, men, women, road
    });
    const storyRandomWordlists = Object.freeze({
        "How Stinkbug Became Black"             : getWordlist(storyWordbanks[0], 10, controller.minWordlen, controller.maxWordlen),
        "Why Coyote's Eyes are the Best"        : getWordlist(storyWordbanks[1], 10, controller.minWordlen, controller.maxWordlen),
        "Dove and Hummingbird Race Each Other"  : getWordlist(storyWordbanks[2], 10, controller.minWordlen, controller.maxWordlen),
        "A Rock to be Jumped"                   : getWordlist(storyWordbanks[3], 10, controller.minWordlen, controller.maxWordlen)
    });

    // misc curated vocab lists
    const vocabWordlists = Object.freeze({
        "-mi Words" : ["xatmi","hewetmi","taʔishmi","diʔishmi","lihimmi","yawalmi","chishmi","lopsilmi","haymi","k'elmi"]
            // while... eating, walking, seeing/watching, making/doing, running, chasing, cutting, fishing, laughing/smiling, painting
    });

    // vocab to add: colors, days of week, months, numbers, family members/relations, animals
        // animals from stories x10: skunk, stinkbug, coyote, fish, dove, hummingbird, bear, eagle , __, __
        // misc animals x10: rabbit,salmon,dog,cat,black ant,squirrel,cougar,deer,hawk,pig
        // misc animals x10: yellowhammer,butterfly,snake(kingsnake,rattlesnake),lizard,woodpecker(?),inchworm, __, __, __
    
    // anchor for global access
    // let targetWordlist = storyVocabWordlists[Object.keys(storyVocabWordlists)[3]];


    // let targetWordlist = storyRandomWordlists[Object.keys(storyRandomWordlists)[3]];


    // init new game
    // controller.newGame(targetWordlist);

    newGameSetVocab('0,vocab');
    newGameSetGridsize(11);
    newGameSetDifficulty(2);
    controller.applyNewGameSettings();
    controller.newGame();



    // debug
    function inject (r=0,c=0) {
        const markerActual = document.createElement('div');
        markerActual.classList.add('marker');
        markerActual.style.top = `calc(var(--wordsearch-pad) + ${0.5+r} * var(--wordsearch-tile-width))`;
        markerActual.style.left = `calc(var(--wordsearch-pad) + ${0.5+c} * var(--wordsearch-tile-width))`;
        wordsearch.appendChild(markerActual);
    }
    
</script>

</body>
</html>